# MiniMQ Wire Protocol Specification (v1.1)

## 1. Overview

This document defines the application-layer protocol used for communication between MiniMQ clients and the BrokerServer. It is a text-based, newline-delimited (\n) protocol that operates over a reliable TCP connection.

### Design Goals

* **Simplicity**: The protocol is easy to understand and debug manually. 
* **Extensibility**: The structure is clear, allowing for new commands to be added in the future. 
* **Clarity**: Commands and data are explicitly separated to avoid parsing ambiguity.

## 2. Transport Layer

* **Connection**: Clients maintain a long-lived TCP socket connection to the server. 
* **Encoding**: All transmitted text data must use UTF-8 encoding. 
* **Message Boundary**: Every command or response is a single line terminated by a newline character (\n). Both client and server receive a complete instruction by reading one line.

## 3. General Command Structure

All instructions sent from the client to the server follow this format:

text COMMAND:PAYLOAD\n ```

* `COMMAND`: An uppercase ASCII string representing the action to be performed (e.g., PRODUCE, CONSUME). 
* :: A colon is the fixed separator between the command and the payload. 
* `PAYLOAD`: The data associated with the command. Its format depends on the COMMAND. 
* \n: A newline character, which marks the end of an instruction.

## 4. Message Serialization Format

When a complete message object needs to be transmitted (e.g., in the PAYLOAD of a PRODUCE command or in the successful response of a CONSUME command), the object is serialized into a single string. Fields are separated by **:::**.

### Field Definitions

| Index | Field Name | Type | Description | Notes | 
| :--- | :--- | :--- | :--- | :--- | 
| 1 | ID | String | A unique identifier for the message | A UUID generated by the client upon message creation | 
| 2 | Topic | String | The topic to which the message belongs | | 
| 3 | Content | String | The actual content of the message | | 
| 4 | CorrelationID | String | The correlation identifier | Used in the Request-Reply pattern to match a response with its request. This field is an empty string for asynchronous messages. | 
| 5 | ReplyTo | String | The reply topic | Used in the Request-Reply pattern to specify the topic where the response message should be sent. This field is an empty string for asynchronous messages. |

### Serialization Example

```text 
b3d4a1e2-a8f1-4b2e-9a1c-12345abcdef:::rpc_requests:::hello world:::c9e8b7a6-f5d4-4c3b-8a2f-fedcba543210:::reply.temp-topic-123 
```

> **Important Note**: If the CorrelationID or ReplyTo fields are not present (i.e., null), an **empty string** "" must be used as a placeholder during serialization to maintain a consistent field count.

## 5. Client Commands

### 5.1 PRODUCE

* **Direction**: Client -> Server 
* **Purpose**: To send (produce) a message to a specific topic. 
* **Payload Format**: A fully serialized message string. 
* **Example**: 
```text 
PRODUCE:111-aaa:::my-topic:::This is a test message.:::::: 
``` 
* **Server Response**: 
* **Success**: The server returns the ID of the message to acknowledge successful receipt. 
```text 
111-aaa\n 
```

### 5.2 CONSUME

* **Direction**: Client -> Server 
* **Purpose**: To consume a message from a specific topic. 
* **Payload Format**: The name of the topic to consume from. 
* **Example**: ```text CONSUME:my-topic ``` 
* **Server Response**: 
* **Message Available**: The server returns the fully serialized message string. 
```text
111-aaa:::my-topic:::This is a test message.:::::: 
``` 
* **No Message**: The server returns the special string NO_MSG. 
```text 
NO_MSG\n 
```

### 5.3 ACK

* **Direction**: Client -> Server 
* **Purpose**: (Optional Implementation) To inform the server that a specific message has been successfully processed and can be safely removed from the queue. 
* **Payload Format**: The ID of the message to acknowledge. 
* **Example**: 
```text 
ACK:111-aaa 
``` 
* **Server Response**: This command is designed to have no response.

## 6. Workflow Examples

### 6.1 Asynchronous Messaging

**Scenario**: Client A sends a message to the logs topic, and Client B consumes it.

```text 
// Client A connects to the server

C (A): PRODUCE:111-aaa:::logs:::User logged in.:::::: S: 111-aaa

// Client B connects to the server

C (B): CONSUME:logs S: 111-aaa:::logs:::User logged in.::::::

C (B): CONSUME:logs S: NO_MSG 
```

### 6.2 Synchronous Request-Reply (RPC)

**Scenario**: RpcClient sends a request to the rpc_requests topic, expecting RpcServer to process it and return an uppercase string.

```text 
// 1. RpcClient sends a request message. Note the CorrelationID and ReplyTo fields. 
C (RpcClient): PRODUCE:222-bbb:::rpc_requests:::hello:::333-ccc:::reply.xyz 
S: 222-bbb

// 2. RpcServer consumes this request message. 
C (RpcServer): CONSUME:rpc_requests 
S: 222-bbb:::rpc_requests:::hello:::333-ccc:::reply.xyz

// 3. After processing, RpcServer sends a response to the 'reply.xyz' topic specified in the request. 
// Note: The CorrelationID of the response MUST be the same as the request's CorrelationID. 
C (RpcServer): PRODUCE:444-ddd:::reply.xyz:::HELLO:::333-ccc::: 
S: 444-ddd

// 4. Meanwhile, RpcClient is waiting on its temporary reply topic. 
C (RpcClient): CONSUME:reply.xyz 
S: 444-ddd:::reply.xyz:::HELLO:::333-ccc:::

// 5. RpcClient receives the response, verifies that the CorrelationID (333-ccc) matches, and completes the synchronous call. 
```

## 7. Error Handling

When the server cannot process a client's request, it returns a response beginning with ERROR.

### Error Response Format

```text 
ERROR::\n 
```

### Error Code Definitions

| Code | Meaning | Description | 
| :--- | :--- | :--- | 
| 400 | Bad Request | The command sent by the client was malformed, e.g., unknown command, missing separator, or unparseable payload. | 
| 500 | Internal Server Error | An unexpected error occurred on the server that prevented it from fulfilling the request. | 
| 501 | Not Implemented | The client requested a valid but not yet implemented feature. |

## 8. Connection Management & Heartbeat

A simple heartbeat mechanism is included to maintain connection health and detect disconnects.

### PING / PONG

**Purpose**:
1.  **Connection Keep-alive**: Prevents network intermediaries (like firewalls and NATs) from closing the TCP session due to long periods of inactivity.
2.  **Liveness Detection**: Allows the client or server to detect if the other end is still responsive.

**PING Command**: 
* **Direction**: Client -> Server 
* **Purpose**: Sent by the client to confirm that the server is online. 
* **Format**: PING: (Payload is empty) 
* **Example**: PING:\n

**PONG Response**: 
* **Direction**: Server -> Client 
* **Purpose**: The server must immediately reply with PONG upon receiving a PING command. 
* **Format**: PONG: (Payload is empty) 
* **Example**: PONG:\n
* **Suggested Implementation**: A client can start a timer to send a PING command periodically, for example, every 30 seconds. If a PONG response is not received within a certain timeout (e.g., 10 seconds), the client can consider the connection lost and attempt to reconnect.

## 9. Protocol Version History

| Version | Release Date | Key Changes | 
| :--- | :--- | :--- | 
| **v1.1** | (Current) | - **Introduced COMMAND:PAYLOAD structure** for better extensibility. | | 
| - **Upgraded message serialization** to use ::: and added CorrelationID and ReplyTo fields. | | 
| - **Formalized support for the Request-Reply pattern** | | 
| - **Standardized the NO_MSG response** | | 
| - **Added Error Handling and Heartbeat mechanisms** 
| **v1.0** | (Initial) | - Basic PRODUCE and CONSUME functionality. | | 
| - Used a topic:content format for PRODUCE. | | 
| - CONSUME returned message content or an empty line.

## 10. Security Considerations

This version of the protocol (v1.1) was designed with **simplicity and ease of implementation as primary goals** and does not include complex security mechanisms. Users must be fully aware of the following limitations:

* **No Authentication**: The protocol does not define any mechanism for user authentication. Any client that can connect to the BrokerServer's TCP port can perform all operations.

* **No Authorization**: There are no Access Control Lists (ACLs). Any client can produce to or consume from any topic.

* **No Encryption**: All data, including message content, is transmitted over the network in **plaintext**. This can lead to data eavesdropping or tampering.

### Security Recommendations

It is strongly recommended to deploy and use MiniMQ **only within trusted network environments**, such as:

* A local development environment (localhost).

    An internal network protected by a firewall.
    An isolated environment using a VPC (Virtual Private Cloud) or a container network (e.g., Docker Network).

For production environments that require a higher level of security, consider encapsulating the TCP connection with TLS/SSL or choosing a message queue product with mature security features.

---

## Appendix A: Glossary

**Broker**: The message broker server; the core component responsible for receiving, storing, and forwarding messages. * **Client**: An application that connects to the Broker, acting as either a Producer or a Consumer.  
**Producer**: A client that creates and sends messages.  
**Consumer**: A client that subscribes to and receives messages.  
**Topic**: A logical category or namespace for messages. Producers send messages to a specific topic, and consumers receive messages from a specific topic.  
**Message**: The unit of data passed between producers and consumers, containing both content and metadata.  
**CorrelationID**: A unique identifier used to correlate a response message with its corresponding request message. It is the key to implementing the RPC pattern.
